"""
Some functions and a class designed to assist in testing semantic analysis
of Nimble programs.

Authors: Greg Phillips

Version: 2022-02-04

"""

from collections import defaultdict

from antlr4 import ParserRuleContext, ParseTreeWalker
from errorlog import ErrorLog
from generic_parser import parse
from nimble import NimbleLexer, NimbleParser, NimbleListener
from nimblesemantics import InferTypesAndCheckConstraints


def do_semantic_analysis(source, start_rule_name):
    """
    Runs semantic analysis on the source, then runs the expression
    type collector to collect the inferred types of all expressions
    on the parse tree.
    """
    tree = parse(source, start_rule_name, NimbleLexer, NimbleParser)
    errors = ErrorLog()
    variables = {}
    walker = ParseTreeWalker()
    analyzer = InferTypesAndCheckConstraints(errors, variables)
    walker.walk(analyzer, tree)
    type_collector = ExpressionTypeCollector()
    walker.walk(type_collector, tree)
    return errors, variables, type_collector.inferred_types


class ExpressionTypeCollector(NimbleListener):
    """
    Collects the inferred types of all expressions in a script in an indexed form,
    to assist with testing. Relies on the type of each expression being stored
    in a `type` attribute on the parse tree node.

    self.inferred_types is a dictionary of dictionaries. The outer key is the line
    number, and the inner key is the expression source, with all whitespace removed,
    as returned by ctx.getText()
    """
    def __init__(self):
        self.inferred_types = defaultdict(dict)

    def exitEveryRule(self, ctx: ParserRuleContext):
        if isinstance(ctx, NimbleParser.ExprContext):
            line = ctx.start.line
            source = ctx.getText()
            inferred_type = ctx.type if hasattr(ctx, 'type') else None
            self.inferred_types[line][source] = inferred_type


def pretty_types(inferred_types):
    """
    Returns a well-formatted string for inferred_types, as generated by
    the ExpressionTypeCollector; useful for debugging.
    """
    output = []
    for line_number in sorted(inferred_types.keys()):
        output.append(f'line {line_number}:')
        for expr in sorted(inferred_types[line_number]):
            output.append(f'  {expr} : {inferred_types[line_number][expr]}')
    return '\n'.join(output)
